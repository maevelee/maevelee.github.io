<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://maevelee.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://maevelee.github.io//" rel="alternate" type="text/html" /><updated>2021-02-04T23:19:14+09:00</updated><id>https://maevelee.github.io//feed.xml</id><title type="html">룰루랄라</title><subtitle></subtitle><author><name>Rula Lee</name></author><entry><title type="html">CS50 4주차 - 선형 검색, 이진 검색</title><link href="https://maevelee.github.io//til/cs50-week4-2/" rel="alternate" type="text/html" title="CS50 4주차 - 선형 검색, 이진 검색" /><published>2021-02-04T00:00:00+09:00</published><updated>2021-02-05T19:38:00+09:00</updated><id>https://maevelee.github.io//til/cs50-week4-2</id><content type="html" xml:base="https://maevelee.github.io//til/cs50-week4-2/">&lt;h2 id=&quot;검색-알고리즘인-선형검색-이진검색을-알아보자&quot;&gt;검색 알고리즘인 선형검색, 이진검색을 알아보자.&lt;/h2&gt;

&lt;p&gt;이전 포스팅에서 알고리즘 실행 시간 표기법을 다뤘다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떤 값이 배열 안에 속해 있는지 찾아볼 수 있는 검색 알고리즘에는 무엇이 있을까?
어떤 알고리즘이 어떠한 상황에 쓰이고, 가장 효율적인 알고리즘은 어떤 것일까?&lt;/p&gt;

&lt;p&gt;어떤 값이 배열 안에 속해 있는지 찾아보기 위해서는 크게 두 가지 검색 알고리즘을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;첫 번째는 &lt;strong&gt;선형 검색&lt;/strong&gt;이며, 두 번째는 &lt;strong&gt;이진 검색&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h3 id=&quot;선형-검색&quot;&gt;선형 검색&lt;/h3&gt;

&lt;p&gt;선형 검색은 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검색한다. 예를 들자면, 1부터 50까지의 숫자 나열에서 50이라는 값을 배열에서 찾기 위해 1부터 50까지 사물함을 하나하나 열어보는 검색 방법이다.&lt;/p&gt;

&lt;p&gt;따라서, 배열이  정렬되지 않고 뒤죽박죽인 상황에서 유용한 검색 방법이다.&lt;/p&gt;

&lt;p&gt;선형 검색은 아래 의사코드와 같이 나타낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Linear-Search.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;선형 검색 알고리즘은 &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;정확하지만 아주 효율적이지 못한 방법이다.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;</content><author><name>Rula Lee</name></author><category term="TIL" /><category term="CS50" /><summary type="html">검색 알고리즘(선형검색, 이진검색)을 알아보자.</summary></entry><entry><title type="html">CS50 4주차 - 배열</title><link href="https://maevelee.github.io//til/cs50-week4-1/" rel="alternate" type="text/html" title="CS50 4주차 - 배열" /><published>2021-02-03T00:00:00+09:00</published><updated>2021-02-03T15:41:00+09:00</updated><id>https://maevelee.github.io//til/cs50-week4-1</id><content type="html" xml:base="https://maevelee.github.io//til/cs50-week4-1/">&lt;p&gt;##배열, 알고리즘과 알고리즘 실행 시간 표기법&lt;/p&gt;

&lt;p&gt;배열이란 한 자료형의 여러 값들이 메모리상에 모여 있는 구조이다. 
현실 세계로 비유하자면 학창시절 교실 뒤에 있던 사물함이다. 컴퓨터의 메모리는 작은 사물함들이 칸칸이 나열된 모습이다.&lt;/p&gt;

&lt;p&gt;사람이라면 이 사물함 안에 들어있는 것을 훑어내서 전체를 파악할 수 있지만 컴퓨터는 그런 능력이 없다. 컴퓨터는 값들에 접근할 때 배열의 인덱스 하나하나에 접근한다. (사물함을 하나하나 열어 내용물을 봐야한다.)&lt;/p&gt;

&lt;p&gt;예를 들어 사물함 안에 각각 1,2,3,4라는 숫자가 있다면, 사람은 이 숫자들을 한순간에 파악할 수 있지만 컴퓨터는 서랍을 한 번에 한 개씩만 열어볼 수 있다.&lt;/p&gt;

&lt;p&gt;다시 말하지만 컴퓨터는 배열의 인덱스 하나하나에 접근한다.&lt;/p&gt;

&lt;p&gt;간단한 프로그램의 경우 실행 시간을 걱정할 필요가 없지만, 처리하는 데이터가 많아지고 작업이 복잡해질수록 실행 시간이 중요해진다. 그렇기 때문에 알고리즘은 정확도도 중요하지만 효율성 역시 중요하다.&lt;/p&gt;

&lt;p&gt;특정 알고리즘의 실행 시간을 표기하는 방법에는 크게 두 가지 방법이 있다. 
첫번째는 알고리즘 실행 시간의 상한을 나타내는 Big O 표기법이며, 두 번째는 알고리즘 실행 시간의 하한을 나타내는  Big Ω이다.&lt;/p&gt;

&lt;h3 id=&quot;big-o&quot;&gt;Big O&lt;/h3&gt;

&lt;p&gt;Big O는 알고리즘 실행 시간의 상한을 나타낸다. 즉, 최악의 경우 필요한 실행 시간이다.
만약 정렬이 되지 않은 1부터 50까지의 숫자 배열에서 50을 찾고자 한다면, 운이 좋으면 한 번에 찾을 수도 있지만 운이 나쁘다면 50번째에 찾을 수도 있다.&lt;/p&gt;

&lt;p&gt;BigO는 이 50번째에 찾을 수도 있을 경우 발생하는 실행 시간을 나타낸다.&lt;/p&gt;

&lt;p&gt;여기서 O는 “on the order of”의 약자로, 쉽게 생각하면 “~만큼의 정도로 커지는”을 뜻한다. O(n)은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가하게 된다. O(n/2) 역시 매우 커지면 1/2는 큰 의미가 없어지므로 O(n) 이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;주로 아래 목록과 같은 Big O표기가 실행 시간을 나타내기 위해 많이 사용된다. 목록 아래로 갈수록 더 빠른 알고리즘이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;O(n^2)&lt;/li&gt;
  &lt;li&gt;O(n log n)&lt;/li&gt;
  &lt;li&gt;O(n)&lt;/li&gt;
  &lt;li&gt;O(log n)&lt;/li&gt;
  &lt;li&gt;O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;big-ω&quot;&gt;Big Ω&lt;/h3&gt;

&lt;p&gt;Big Ω 는 알고리즘 실행 시간의 하한을 나타낸다. 즉, Big O를 설명할 때 든 예시에서 “운이 좋아서 한 번에 숫자 50을 찾은 경우” 발생하는 실행 시간을 나타낸다. 
주로 아래 목록과 같은  Big Ω 표기가 많이 사용된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ω(n^2)&lt;/li&gt;
  &lt;li&gt;Ω(n log n)&lt;/li&gt;
  &lt;li&gt;Ω(n)&lt;/li&gt;
  &lt;li&gt;Ω(log n)&lt;/li&gt;
  &lt;li&gt;Ω(1)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rula Lee</name></author><category term="TIL" /><category term="CS50" /><summary type="html">배열, 알고리즘과 알고리즘 실행 시간 표기법을 알아보자.</summary></entry><entry><title type="html">블로그 시작</title><link href="https://maevelee.github.io//blog/first-post/" rel="alternate" type="text/html" title="블로그 시작" /><published>2020-01-29T00:00:00+09:00</published><updated>2020-01-29T00:00:00+09:00</updated><id>https://maevelee.github.io//blog/first-post</id><content type="html" xml:base="https://maevelee.github.io//blog/first-post/">&lt;p&gt;남들 다 하는 블로그 나도 만들었다.&lt;/p&gt;

&lt;p&gt;세팅하면서 tzinfo 에러 떠서 화났는데
막상 만들고 나니까 엄청 뿌듯하다!!!!!&lt;/p&gt;

&lt;p&gt;이런 블로그 형식은 처음 경험해보는데
티스토리나 브런치보다 간결하고
또 변경 사항이 생길때마다 terminal에서 수정해야 하는게 아날로그 감성이라 마음에 든다.&lt;/p&gt;

&lt;p&gt;앞으로 천천히 공부한 거 정리해 올려야징&lt;/p&gt;</content><author><name>Rula Lee</name></author><category term="Blog" /><category term="Blog" /><summary type="html"></summary></entry></feed>