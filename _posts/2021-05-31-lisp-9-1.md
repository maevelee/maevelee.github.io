---
title: "LISP 9주차 - Applicative Programming"
excerpt: "LISP에서 함수를 실시간으로 사용하는 방법을 알아보자."
categories:
  - lectures
tags:
  - Clang
last_modified_at:
---

## Applicative Programming

이번 시간엔 LISP prompt에서 함수를 실시간으로 사용하는 방법에 대해서 알아보자. 

Passing functions as inputs to other functions and returning functions as values. 

## Funcall

function임을 나타내는 #기호와 function이름을 쓰고, 그 뒤에 인자를 입력한다.

```lisp
(funcatll #'+ 1 2 3 4 5)
    = 15 ;;funcall 함수는 해당 함수가 요구하는 값을 인자로 받는다. 더하기 함수는 숫자를 인자로 받으므로, list가 아니라 숫자 그 자체를 입력하여 주면 된다. 
```

## Mapcar
list안의 각 원소들에 특정 함수를 대입하여 값을 return 한다. 결과로 list를 출력한다. 

```lisp
(defun MySquare (n) (*n n))
(mapcar #'MySquare `(1 2 3 4 5))
     = (1 4 9 16 25) ;;각 list 원소에 mysquare 함수를 대입하여 값이 출력된다. 
```

```lisp
(mapcar #'+ '(1 2 3))
    = (1 2 3) ;; list안의 1, 2, 3 각 원소에 +를 대입하였으므로 값으로 1 2 3이 출력된다.
(mapcar #'- '(1 2 3))
    = (-1 -2 -3) ;;list안의 1, 2, 3 각 원소에 -를 대입하였으므로 값으로 -1, -2, -3이 출력된다. 
(mapcar #'list ('a b c))
    = ((a) (b) (c)) ;;a, b c 각 원소를 list화 시킨다는 것이므로, ((a), (b), (c))가 값으로 출력된다. 
```

## Eval과 Apply함수 복습

- Eval

LISP은 evaluation을 생략하고자 할 때 quote를 앞에 붙여서 evaluation을 방지한다.
이러한 quote를 무시하고 그냥 값을 evaluate 하는 것이 eval함수이다.

```lisp
(eval '(mysquare 7))
    = 49 ;; (7*7)
```

mysquare함수 앞에 quote를 추가시켜서 evaluate하지 않도록 하였으나, eval함수를 쓰게 되어 값이 evaluate되었다.  


- Apply 함수

apply함수의 경우 무조건 리스트 형태로 값을 넣어야 하는 특징이 있다.

```lisp
(apply #'mysquare 7)
 = error
```
위 코드와 같이 apply 함수를 쓰면서 list형태를 대입하지 않았을 경우 error가 된다.

```lisp
(apply #'mysquare '(7))
    = 49
```

list 형식으로 '(7)을 넣어주자 값이 정상적으로 출력됨을 확인할 수 있다. 

## Table 형태 값을 Mapcar로 다루기 

table형태의 값을 mapcar 내장함수로 출력해보자. 

```lisp
(defvar *words* '((one uno) (two deux) (three trois) (four quatre)))

(defun traslate (x)
    "an example of mapcar int the form of table."
    (second (assoc x *words*))) ;;assoc으로 입력받은 x값과 전역변수 words안에 있는 원소와 연관 있는 것을 가져온다. 그리고, 그 값 중에 두 번째 행에 있는 값을 가져온다. (words 값)


(mapcar #'translate '(three one four one))
    = (uno deux quatre deux) ;;mapcar 함수로 translate 함수를 '(three one four one) 리스트 안의 각 원소에 대입시켜 대입시킨 결과를 출력한다.
```


## Lambda
이전에 정의되어 있지 않은 함수를 정의하여 prompt에서 사용할 수 있도록 하는 함수

```lisp
((lambda (x) (+ x x)) 7) ;; x라는 입력 변수를 받고, 함수가 수행할 작업을 입력하고, 입력 변수에 들어갈 값을 지정한다.
    = 14
```

## Find-if
입력한 함수의 조건을 만족하는 list 원소 값을 반환하는 내장함수.

```lisp
(find-if #'oddp '(2 4 6 7 8))
    = 7
```
```lisp
(find-if #'(lambda (x) (> x 10)) '(2 4 6 8)) ;;함수명을 지정하지 않은 lambda 함수에 입력 변수 x를 입력받고, x와 10을 비교하여 nil/true 값을 반환한다. 
    = nil ;;이 경우 입력한 list안에 10보다 큰 값이 없으므로, nil값이 반환된다.)
```
## Assoc

assoc은 사용자가 입력한 값과 연관있는 값을 가져와 반환한다.

```lisp
(defun my-assoc (key table)
"my version of assoc(iation)" ;;assoc 내장함수 구현하기.
    (find-if #'(lambda (entry) (equalp key (car entry))) table))
```
엄청 어려워보이는데ㅠㅠ 하나하나 생각해보쟈.

이 my-assoc이라는 함수는 key값과 table값을 받아 결과를 출력해준다. 

이 함수는 table 안에 있는 값 중에서 find-if 내장함수로 함수의 조건을 만족하는 값을 return하는데, 이 find-if로 조건 판별을 할 함수로 lambda 함수를 설정한다. 이 lambda함수는 entry라는 입력변수를 갖는다. 만약에 입력한 key값이 entry값의 맨 첫번째와 같으면 해당 값을 반환한다. 


## Remove-if

조건에 해당하면 값을 지우는 내장함수.

```lisp
(remove-if #'numberp '(2 for 1 sale)) ;;숫자면 지운다.
    = (for sale)
```

## Remove-if-not
조건에 해당하지 않으면 값을 지우는 내장함수.

```lisp
(remove-if-not #'plusp '(2 0 -4 6 -8)) ;; 양수가 아니면 지운다. 
    = 2 6

(remove-if-not #'(lambda (x) (> x 3)) '(2 4 6 8)) ;;3보다 큰 x값만 출력하라.
    = (4 6 8)
```

## Reduce

list로 입력값을 받으며, 전체의 결과를 single result(하나의 값)으로 되돌려준다. 

mapcar은 각각의 원소에 함수를 적용하여 각각의 값을 return했다면 reduce는 하나의 값을 되돌려준다. 
apply와 동일한 작업을 수행한다. 

```lisp
(reduce #'append '((one uno) (two deux) (three trois)))
    = (one uno two deux three trois)
```

## Every

모든 조건을 만족할 시 true를, 그렇지 않을 시 f를 return하는 내장함수

```lisp
(every #'numberp '(1 2 3))
    = t
```
```lisp
(every #'numberp '(1 2 a b))
    = nil
```

## Trace

함수의 작업 내용을 추적하여 prompt에 띄워주는 함수.

```lisp
(defun half (n)
    "returning the half of n"
    (/ n 2.0))

(defun average (x y)
    "returning the average of x and y"
    (+ (half x) (half y)) ;;x와 y를 나눈 값을 서로 더한다.
```

trace 내장함수를 사용하여 이 두 half와 average 값을 추적해보자. 

```lisp
(trace half average) ;;half와 average함수를 trace 하라.
    = (average half)

(half 9)
    = (half 9)
      returned 4.5
      4.5  
    ;; half 함수를 사용하였을 때 함수가 작동되는 순서를 전부 출력해준다. 

(half 10)
    = (half 10)
      returned 5.0
      5.0

(average 9 10)
    = (half 9)
      returned 4.5
      (half 10)
      returned 5.0
      returned 9.5
      9.5

      ;; average 함수는 입력변수를 각각 half한 뒤 두 값을 더한다. trace 함수를 사용하면 이 수행 작업 상태를 전부 출력하여 보여준다. 
```