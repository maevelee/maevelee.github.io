---
title: "CS50 4주차 - 병합 정렬"
excerpt: "정렬 알고리즘(병합 정렬)을 알아보자."

categories:
  - TIL
tags:
  - CS50
last_modified_at: 2021-02-05T01:07:00-13:00
---

## 병합 정렬을 알아보자.

이전 게시글에서 재귀 개념을 설명했다.

이 재귀 개념을 사용한 정렬 알고리즘이 바로 마지막으로 다룰 병합 정렬이다.


### 병합 정렬


병합 정렬은 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐 나가며 정렬을 하는 방식이다. 

첫 번째로 배열의 왼쪽 절반을 정렬하고, 두 번째로 배열의 오른쪽 절반을 정렬하고, 마지막으로 두 배열을 병합한다. 그리고 이 과정은 재귀적으로 구현된다. 


아래 숫자를 한 번 병합 정렬로 오름차순으로 정렬해보자.

7 4 5 2 6 3 8 1 


1) 먼저 숫자들을 반(왼쪽 반, 오른쪽 반)으로 나눈다. 

7 4 5 2 | 6 3 8 1


2) 그리고 나눠진 부분 중 왼 쪽 부분을 한 번 더 반으로 나눈다.

7 4 | 5 2 | 6 3 8 1


3) 마지막으로 한 번 더 나눈다.

7 | 4 | 5 2 | 6 3 8 1


4) 이제 |를 기준으로 숫자가 하나밖에 남지 않았으므로 더 이상 나누지 않고, 두 숫자(왼쪽에 있는 7과 오른쪽에 있는 4)를 병합한다. 
이 때, 오름차순 정렬이므로, 작은 숫자를 앞으로 오도록 하고, 큰 숫자를 뒤로 오도록 한다.

4 7 | 5 2 | 6 3 8 1


5) |를 기준으로 왼쪽 부분이 정렬됐으므로 나머지 오른쪽 부분인 5 2 역시 같은 방법으로 병합하여 정렬한다.

4 7 | 2 5 | 6 3 8 1


6) 왼쪽 부분인 4 7 과 오른쪽 부분인 5 2 가 모두 정렬되었으므로 이 둘을 병합한다. 
각 부분들의 숫자들을 앞에서부터 순서대로 읽어 비교하여 더 작은 숫자를 병합되는 부분에 가져온다. 
4와 2를 비교하여 2를 먼저 가져오고, 그 후에 4와 5를 비교하여 4를 가져오고, 7과 5를 비교해서 5를 가져오고, 마지막으로 남은 7을 가져온다.

2 4 5 7 | 6 3 8 1


7) |를 기준으로 왼쪽 부분이 정렬됐으므로 나머지 오른쪽 부분인 6 3 8 1 역시 위와 동일한 과정을 거쳐 정렬해준다. 

2 4 5 7 | 1 3 6 8


8) |를 기준으로 왼쪽 부분과 오른쪽 부분이 모두 정렬됐으므로 둘을 병합해준다. 
2와 1을 비교하여 1을 먼저 가져오고, 2와 3을 비교하여 2를 가져오고, 4와 3을 비교하여 3을 가져온다. 
이 과정을 병합이 끝날 때까지 진행하면 아래와 같이 정렬이 완료된다.

1 2 3 4 5 6 7 8 


전체 과정을 요약해서 도식화해보면 아래와 같다.

7 | 4 | 5 | 2 | 6 | 3 | 8 | 1 → 가장 작은 부분 (숫자 1개)으로 나눠진 결과이다.
4 7 | 2 5 | 3 6 | 1 8 → 숫자 1개씩을 정렬하여 병합한 결과이다.
2 4 5 7 | 1 3 6 8 → 숫자 2개씩을 정렬하여 병합한 결과이다.
1 2 3 4 5 6 7 8 → 마지막으로 숫자 4개씩을 정렬하여 병합한 결과이다. 


가장 아래 배열이 하나 있고, 이를 절반으로 나누어 올리고, 나눈 절반을 다시 절반으로 나누어 올리고, 나눈 절반의 절반을 다시 나누는 식이다. 

이처럼 무언가를 계속해서 절반으로 나누는 알고리즘은 로그 함수로 설명할 수 있다. 

위의 예시처럼 크기 8인 배열을 쪼개서 크기 1인 배열 8개로 만드는 데 필요한 과정은 밑이 2인 log n이다. 컴퓨터 과학에서는 수식을 간단히 하는 경향이 있으므로, 대략 log n이다. 

따라서, 병합 정렬 실행 시간의 상한은 O(n long n)이다. 숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸리기 때문이다.

실행 시간의 하한 역시 Ω(n log n)이다. 숫자들이 이미 정렬되었는지 여부에 관계없이 나누고 병합하는 과정이 필요하기 때문이다. 


**O(n^2) - 버블 정렬
O(n log n)
O(n) - 선형 검색
O(log n) - 이진 검색
O(1)

Ω(n^2) - 버블 정렬
Ω(n log n)
Ω(n) 
Ω(log n)
Ω(1) - 선형 검색, 이진 검색**


어쩌면 O(n log n)이 차트의 위에서 두번째에 위치하고 있어서 O(n^2)보다 빠르면 얼마나 빠르겠냐고 할 수 있지만, 사실 O(n log n)은 꽤 강력하다.


<iframe width="560" height="315" src="https://youtu.be/embed/ZZuD6iUe3Pc" frameborder="0" allowfullscreen></iframe>


이 동영상의 왼 편의 상 중 하가 각각 선택 정렬, 병합 정렬, 버블 정렬이다. 

동영상을 본다면 병합 정렬(O log n)이 얼마나 좋은 정렬 알고리즘인지 알 수 있을 것이다. 


