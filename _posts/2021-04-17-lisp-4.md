---
title: "LISP 4주차 - LISP의 조건문"
excerpt: "LISP의 조건문을 알아보자."
categories:
  - lectures
tags:
  - lisp
last_modified_at:
---

## LISP의 조건문

구조적 프로그래밍 관점에서 프로그래밍을 하기 위해서는 시퀀스, 조건문, 반복문 세 가지를 알아야 한다.  
LISP의 조건문을 알아보자.

---

## LISP의 IF function

Lisp의 if 조건문은 test part와 test part가 참일 때 수행되어야 할 true-part, 거짓일 때 수행되어야 할 false-part로 나뉘어진다.  
  

간단하게 5가 홀수면 odd number을 출력하고, 짝수면 even number을 출력하는 코드를 통해 조건문을 살펴보자.

```lisp
(if (oddp 5) ‘odd-number ‘even-number) 
	= odd-number

"oddp 5 -> test part"  
"‘odd number -> true-part" 
"‘even-number -> false-part"
```

조건문에서 false-part는 스킵이 가능하다. 이런 경우 test part의 값이 false면 디폴트로 nil값이 출력된다.

```lisp
(if (evenp 7) ‘odd-number) 
	= nil
```

Test part에서 괄호를 쓰는 이유는 해당 내장함수를 지정해야 하기 때문인데, 내장함수를 쓰지 않고 조건문을 작성할 수도 있다.

```lisp
(if t ‘true-part ‘false-part) ;;T는 special symbol로 지정되어 있기 때문에 내장함수처럼 괄호를 쓸 필요가 없다.
	= true-part ;; T값은 항상 참이므로 true-part를 반환한다.
```  

**+)** 추가적인 조건문 예제  

```lisp
If (> 3 5) ‘first-is-greater-than-second ‘second-is-greater)
	= second-is-greater ;;3이 5보다 크면 first~를 출력하고, 그 반대면 second~를 출력한다.
(defun MyAbs (x)
	“My version of absolute value”
	(If (< x 0) (- x) x)) ;;x가 0보다 작으면 x에 -을 붙이고, 0보다 크면 그대로 출력한다. 
```

---

## LISP의 COND expression

일반적인 조건문은 cond로 이루어진다. C언어의 case문과 같이 여러가지 test part가 있는 조건문이라고 보면 된다.  
Cond 함수를 한 번 살펴보자.

```lisp
(defun MyCompare (x y)
	“This function compares two numbers, i.e., x and y”
	(cond ((= x y) ‘numbers-are-the-same) ;;하나의 condition part
	      ((< x y) ‘first-is-smaller) ;;하나의 contion part
	      ((t ‘first-is-bigger))) ;;위 두 condition이 아닐 경우, 항상 first~를 출력해라. 
```

**+)** 추가적인 cond문 예제

```lisp
(defun where-is (x)
	“This function predicates the country.”
	(cond ((equals x ‘paris) ‘france)
	     ((equals x ‘london) ‘france)
	     ((equals x ‘beijing) ‘china)
	     (t ‘unknown)))

(defun compute (op x y)
	(cond ((equals op ‘sum-of) (+ x y)) ;;만약 op가 sum-of로 입력되면 x y를 더하여 출력한다.
	      ((equals op ‘product-of) (* x y)) ;;op가 product-of로 입력되면 곱하여 출력한다.
	      (t ‘unknown))) ;;그 외의 것이 입력되면 unknown을 출력한다.
```

---

## LISP의 when과 unless
Unless는 test part가 false이면 true part를 수행한다.
When은 if 문에서 test part가 true일 때만 수행한다.

```lisp
(defun picky-multiply (x y)
	“The example of unless and when”
	(unless (oddp x) (incf x)) ;;만약 x가 홀수가 아니면 x에 하나를 증가시킨다. (홀수를 만듦)
	(when (oddp y) (decf y)) ;;y가 홀수면 y를 하나 감소시킨다. (짝수를 만듦)
	(* x y)) *업데이트 된 값으로 x y를 출력한다. 

;;Incf: 값을 증가시키는 내장함수. 증가값을 지정하지 않을 시 1이 증가함.
;;Decf: 값을 감소시키는 내장함수. 증가값을 지정하지 않을 시 1이 감소함.
```

---

## LISP의 AND
AND는 동시에 만족하는 것을 나타낸다. (conjunction)

```lisp
(defun small-positive-oddp (x)
	“small positive odd numbers”
	(and (< x 100) (> x 0) (oddp x)))
```
위 코드는 x가 100보다 작고, x가 0보다 크고, x가 홀수인 것을 동시에 고려하는 코드이다. 만약 조건을 모두 만족하면 t를, 아니라면 nil을 출력한다.

---

## LISP의 OR
OR은 고려할 대상 중 하나를 만족하는 것을 나타낸다. (disjunction)

```lisp
(defun gtest (x y)
	“first is greater than second or one of them is zero”
	(or (> x y) (zerop x) (zerop y))) 
```
위 코드는 x가 y보다 크거나, x와 y 둘 중 하나의 값이 0인지 알아보는 코드이다. 

---

## LISP의 Boolean Functions

```lisp
(defun logical-and1 (x y)
	(if x (if y t))) ;;만약 x가 참이면, 만약 y도 참이면 t를 출력하라.
	= t
(defun logical-and2 (x y) 
	(and x y t)) ;;만약 x와 y가 참이면 t를 출력하라.
	= nil
(defun logical-or (x y)
	“returning t or nil as the result of x or y”
	(cond (x t)
	     (y t)
	     (t nil))) ;;전부 다 아니면 nil이다. 
(defun demorgan-and (x y)
	(not (or (not x) (not y)))) ;; (and x y)
	(not (and (not x) (not y)))) ;; (or x y)
```

---

## LISP의 Apropos
Apropos란 특정 내장함수의 완전한 스펠링을 모를 때 시스템에서 유사한 함수명, 그 알파벳이 들어가있는 모든 함수명을 되돌려주는 것이다. 

```lisp
(apropos ‘sqrt)
```
위 코드를 작성하면 LISP이 가지고 있는 관련된 내장함수를 되돌려 프롬프트에 출력한다.  

혹은, 이 apropos를 사용하지 않을 수도 있다. Allegro Common Lisp 프로그램 상단의 A버튼을 클릭하면 함수명이 검색된다. 

