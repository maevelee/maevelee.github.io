---
title: "LISP 5주차 - LISP의 EVAL Notation"
excerpt: "LISP의 EVAL function을 알아보자."
categories:
  - lectures
tags:
  - lisp
last_modified_at:
---

## LISP의 EVAL Notation
LISP의 EVAL 함수를 알아보자. 

## EVAL function
**EVAL은** ***evaluation을 줄인*** Lisp의 내장함수이다.
evaluation이란, 우리가 하나의 함수 단위인 (+2 7)을 입력하면 덧셈에 대한 결과값을 사용자에게 되돌려주는데, 이 결과값을 되돌려주는 것이 바로 evalutation이다. *((+2 7) evaluates to 12.)*

```lisp
(/ (+ 2 7) (- 8 4))
	= 9/4
```
Lisp은 위 코드를 (+ 2 7)과 (- 8 4)를 연산하고, 두 값을 나누는 순서로 연산하여 9/4를 evaluate한다.

## Self-evaluating

Lisp은 숫자, special symbol인 t와 nil을 self-evaluating한다.
처음 lisp에서 t, nil, 숫자를 입력했을 때 프롬프트에서 에러메세지 없이 받아들였던 것을 self-evaluation이라고 생각하면 편하다. 

## Defining Functions
```lisp
(defun MyAverage (x y)
	“my version of average of x and y”
	(/ (+ x y) 2.0)

(defun mysquare (n)
	“my version of square of n”
	(* n n))

(defun total-cost (quantity price handling-charge)
	“computing total-cost using quantity, price, and HC”
	(+ (* quantity price) handling-charge))
```
## Variables

Lisp에서는 작성한 함수 내에서 변수를 사용할 수 있다. 
예를 들어 **(defun Myadd (x y)** 라고 하는 함수가 있다면, x y가 변수로 사용되는 것이다.  

프롬프트에서 변수를 설정하고자 한다면 setf 내장함수를 이용한다. 
예를 들어 (setf x 5)라고 하는 코드를 프롬프트에 입력하면, x에 5가 저장되므로 컴퓨터가 x를 5로 인식한다.

```lisp
(setf x 5)
x
  = 5
```

## Special Functions

인자가 없는 함수  

```
(defun no-args ()
	Example function with no arguments”
(* 7 9) 
```

## Internal structure of symbols
```lisp
(symbol-name ‘a)
(symbol-function ‘equal)
```

## Lambda notation (unnamed function)

Unnamed function은 defun으로 정의하던 함수를 실시간으로 사용할 수 있게 해준다. 즉, 함수 이름 없이 실시간으로 사용되어질 수 있도록 한다.  
Lisp은 인터프리터 언어이다. 하지만 일반적으로 project를 만들어서 그 안에 함수를 정의하고 load하는 방식을 많이 사용한다.  
Lambda는 이러한 불편을 줄이는 기능이다. 함수를 지정할 때 사용하는 defun과 함수명을 사용하지 않고 프롬프트 창에 바로 함수를 입력하므로 프로젝트를 저장하고 load하는 불편을 줄일 수 있다. 

```lisp
((lambda (n) (/ n 2.0)) 10)
	= 5.0
```
Lambda는 함수명이며, defun과 다른 함수명을 입력할 필요 없이 인자만 입력받는다. 그 뒤 띄어쓰기를 하고 수행할 내용을 입력한다. 마지막으로 인자에 들어갈 값을 넣어주고 괄호를 닫는다. 

## Lisp의 변수 범위
Lisp는 자체 함수 내에서만 범위를 갖는다. 아래 코드를 보고 변수 범위를 확인해보자.  

```lisp
(defun myparent (n)
	“parent function”
	(mychild (+ n 2))) ;; n is local to parent.

(defun mychild (p)
	“child function”
	(* 2 p))
```
코드를 보면 argument n은 myparent 함수 내에서만 작동하고, argument p는 mychild 안에서만 작동하는 것을 볼 수 있다. 함수와 함수를 연결하여 사용할 수는 있지만, argument의 위치를 이동시키는 것은 불가능하다. 

## Eval, Apply, Funcall 함수
여러 번 언급했지만 lisp 프롬프트 창에서 ‘를 앞에 붙인 채로 문자, 숫자, 리스트 등을 입력하면 lisp은 이를 evaluate 하지 않는다.  

```lisp
‘(+ 2 5)
	= (+ 2 5) ;;'때문에 evaluate하지 않는다.
``` 

하지만 quote가 붙은 입력값을 evaluation하는 함수가 있다.  
Eval, Apply, Funcall이 일반적으로 쓰인다. 

1. **Eval 함수를 이용할 경우**

```lisp
(eval ‘(+ 2 5))
	= 7

(eval ‘(mysqure 7))
	= 49

(eval ‘(list ‘a ‘b ‘c))
	= (a b c)
```
위 코드를 보면 (+ 2 5)앞에 quote를 붙여서 evaluate하지 못하게 했음에도 결과가 (+ 2 5)가 아닌 7로 나오는 것을 알 수 있다.  
이는 eval함수를 사용하였기 때문이다. Eval을 사용하면 ‘를 무시하고 evalutate한다. 

2. **Apply 함수를 사용하는 경우**

```lisp
(apply #’+ ‘(2 5))
	= 7

(apply #’mysquare ‘(7)) *mysquare 함수에 ‘(7)이라는 리스트를 입력받아 mysqure에 7을 적용한다.
	= 49

(spply #’list ‘(a b c))
	= (a b c)
```
Apply 함수는 특정 함수 자체를 리스트에 적용시켜 주는 것인데, 역시 eval과 동일한 작업을 수행하나 입력 양식이 다르다.  
Apply의 경우 #을 입력하고 그 뒤에 ‘를 입력한 뒤 실행하고자 하는 함수나 연산자를 입력한다. 그리고, 리스트의 형식으로 인자를 입력한다.

3. **Funcall 함수를 사용하는 경우**

Funcall는 apply과 동일한 작업을 수행하나 인자를 리스트의 형식으로 입력 받지 않아도 된다.

```lisp
(funcall #’mysquare 7)
	= 49

(funcall #’list ‘a ‘b ‘c)
	= (a b c)
```


