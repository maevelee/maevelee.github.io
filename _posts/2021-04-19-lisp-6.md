---
title: "LISP 6주차 - LISP의 반복문, 무한루프"
excerpt: "LISP의 반복문과 무한루프를 알아보자."
categories:
  - lectures
tags:
  - lisp
last_modified_at:
---

## LISP의 Iteration and Block Structure
LISP의 반복문인 Do 문법과 무한 루프에 대해 알아보자. 

---

## Dotimes and Doilist
LISP의 반복문 문법 중 하나인 Dotimes와 Dolist를 알아보자.  
Dotimes와 Dolist 반복문은 보다 단순한 형태의 것을 반복 수행한다.  

```lisp
(dotimes (index-var n [result-from])
	Body)
Dolist(index-var list [result-from])
	Body

"반복하는 횟수 –> index-var n"
"Dotimes의 결과로 반환하는 변수, 심볼 등 -> [result-form] (지정해도 되고 안해도 된다.)"
"내용 –> Body"
```

## Dotimes 예제

```lisp
(defun counting (n) 
"This is an example of dotimes"
	(dotimes (i n i) 
	(format t ”~&i is ~S…” i)))

(counting 7)
	= I is 0…
	  I is 1…
	  I is 2…
	  I is 3…
	  I is 4…
	  I is 5…
	  I is 6…
```

## Dolist 예제

```lisp
(defun roses (Colors)
"This is an example of dolist"
(dolist (x Colors ‘flowers done)
	(format t “~&Roses are ~S.” x)))

(roses ‘(red white yellow black))
    =Roses are red
	 Roses are white
	 Roses are yellow
	 Roses are black.
	 Flower_done
```
## LISP의 Format
Format이란 정형화된 문장을 의미한다. LISP의 내장함수이며, stdio이다. 즉, “”안에 있는 내용을 그대로 출력하는 것이다. 

```lisp
(format t "This is an example")
	= This is an example
	  nil ;;Side effects
Format 함수는 nil값을 side effects로 반환한다. 
```
```lisp
(format t "~&This is an example…")
	= This is an example…

;; ~ = 명령한 것을 수행하라
;; & = 문장의 첫 줄로 가라 
;; % = enter(return)
;;~S = 이중 따옴표 이내에 있는 것을 x로 써라 (c언어의 %와 비슷함.)
```

## return문
Exiting the body of an iteration from w/o looping any further.

```lisp
(defun find-first-odd (list-of-numbers) ;;첫 번째 홀수를 찾는 프로그램
	(dolist (e list-of-numbers) ;;list-of-numbers안의 원소를 찾아라.
	  (format t "~&Testing ~S…" e) 
	  (when (oddp e) ;;만약 홀수를 찾으면
		(format t "found an odd number.") ;;문장을 출력하고
		(return e)))) ;;찾은 값을 리턴하라.

(find-first-odd ‘(2 4 6 7 8 9))
	= Testing 2…
	  Testing 4…
	  Testing 6…
	  Testing 7… found and odd number.
```
```lisp
(format t "~%~%~%This is …")
	=
	
	This is …
```
```lisp
(format t "~%~%This is …~%~%")
	=
	
	This is …
	
	
	Nil
```

## 팩토리얼 값을 구하는 반복문

```lisp
(defun it-fact-dotimes (n)
"computing factorial value of input n"
(let ((prod 1)) ;production값 (계산되는 값)을 1로 설정하라
(dotimes(I n prod) ;;0부터 n-1까지의 index값을 갖는다.
    (setf prod (* prod (+ I 1)))))

(it-fact-dotimes 1)
	= 1
```

## 집합을 나타내는 함수

```lisp
(defun it-intersection (x y)
"the intersaction of x and y"
(let ((result-set nil)) ;;”두 집합의 교집합합은 공집합이다” 를 설정한다.
  (dolist (element x (reverse result-set) ;;x의 집합에 각각 접근하는 변수를 element로 설정하고, 결과값인 result-set 값을 반대로 설정한다. (먼저 들어간 값이 우측으로 들어가기 때문에 이를 좌측배열로 만들어주기 위해서 반대로 설정한다. 즉, 먼저 찾은 element를 좌측으로 보내기 위해 이 코드를 추가시킨 것.)
  (when (member element y) ;;조건문. 만약 x집합의 element가 y의 집합의 member면 (x집합의 원소가 y집합의 원소이면, 교집합이면)
  (push element result-set)))) ;;element를 result-set에 추가시킨다.

(‘a b c d) ‘(c d e f))
	= (c d)
```
## LISP의 Do와 Do*

앞서 dolist와 dotimes 반복문을 공부했으나 보다 일반적인 형태의 반복문은 Do와 Do\*이다.  
이 둘의 차이는 let과 let\*에 대한 차이점과 같다.  

**Do** = 초기값과 종료값을 한 번에 설정하여 반복한다. 마지막에 test part가 들어가야 하며, 이 test값이 true일 경우 action을 수행한다. (all at once)  

**Do\*** = 한 번에 하나씩 정의가 된다. (once at a time) 

## Do
간단한 예제를 통해 Do 반복문을 알아보자.

```lisp
(defun launch (n)
"understanding do loop"
Do (( cnt n (- cnt 1))) ;;count variable인 cnt를 지정하고 cnt는 반복될 때마다 cnt – 1을 수행한다. 
(zerop cnt) (format t “Blast off!”)) ;;만약 cnt가 0이면 (test part)
(format t “~S…” cnt))) ;;(body) 
	= 10…9…8…7…6…5…4…3…2….1…Blast off! ;;do로 반복함에 따라 10부터 1까지 수가 세어지고, 마지막에 cnt값이 0이 될 시 Blast off! 를 출력한다. 
```

## Do* 
간단한 예제를 통해 Do\* 반복문을 알아보자.

```lisp
(defun ffo-with-do* (ListOfNumbers)
"finding a first odd number in the input list, ListOfNumbers" ;;List of numbers안에 있는 숫자들 중 첫 번째 홀수를 찾는다.
(do* ((x ListOfNumbers (rest x))
(e first x) (first x)))  
(null x) nil) ;;x가 다 비어있으면 (더 이상의 원소가 없으면) nil값을 반환한다.
(if (oddp e) (return e)))) (만약 e값이 홀수라면 return한다.)

;;Read : 하나의 값을 읽어오는 함수
```

## Infinite loops
Do의 test part가 nil이면 무한히 반복한다.

```lisp
(defun read-a-number ()
	(do ((answer nil)) ;;answer값을 nil로 초기화해준다.
    (nill) ;;nil 일 때 무한히 반복된다. 
    (format t "~&Please type a number: ") 
    (setf answer (read)) ;;사용자로부터 값을 입력받아 answer 변수에 넣는다. 
    (if (numberp answer) ;;만약에 입력받은 값이 숫자면
        (return answer)) ;;숫자를 return한다. 
	  (format t "~&Sorry, ~S is not a number. Try again." Answer)) ;;그렇지 않으면 try again 메시지를 출력한다. 

	= Please type a number: abc
	  Sorry, abc is not a number. Try again. 
	= Pleas e type a number: 3
	  3
```
## Advanced Topics
자주 쓰이지는 않지만 알고 있으면 좋은 함수들

1. **prog 함수**

Prog1 – 첫번째 표현에 대한 값을 return한다.  
Prog2 - 두 번째 표현에 대한 값을 return한다.  
Progn – 마지막 표현에 대한 값을 return한다.  

```lisp
(prog2 (setf x’foo) ;;prog로 묶이는 것들 중에서 두 번째 값을 return하라
	(setf x ‘bar)
	(setf x ‘baz)
	(format t "~&X is ~S" x))
	= X is BAZ ;;setf변수가 최종적으로 담은 값은 baz이며
	BAR ;;prog2 함수로 인해 x가 두 번째로 담은 값인 bar가 return된다.
```

## Lambda-list Keywords
Lamda-list keywords는 특정한 함수의 입력 변수를 비 고정적으로 활용할 수 있는 keywords이다.

1. **\&optional** - 한 개의 변수에 대해서 선택적으로 지정할 수 있음을 나타낸다. 즉, 입력값 하나를 선택적으로 받을 수 있다. 

```lisp
(defun foo (x &optional y) ;;x를 foo함수의 argument로 받으나, y는 받을수도 있고 안 받을수도 있다. 선택적이다.
"example of optional keyword"
(list x y))

(foo ‘a)
	=  (a nil) ;;입력한 a값은 그대로 들어가고, 선택적으로 입력받지 못한 y값은 nil로 처리되어 출력됨.
```

2. **\&key** - \&optional이 여러 개인 경우에 해당한다. 여러개의 값을 선택적으로 받을 수 있다.

```lisp
(defun make-sundae (name &key (size ‘regular) ;;변수 name을 사용하고 선택적으로 size라는 값을 받는다. 이 size에는 ‘regular라는 값을 기본적으로 넣어준다.
		(ice-cream ‘vanilla) ;;선택적으로 ice-cream이라는 값을 받으며 이 ice-cream에는 'vanilla값을 기본적으로 넣어준다.
		nuts) ;;선택적으로 nuts라는 값을 받는다.
"example of key keywords"
(list name size ice-cream nuts)) ;;값을 출력한다.

(make-sundae ‘my-ice)
	= (my-ice regular vanilla nil) ;;name을 제외한 다른 값을 넣지 않았을 때
(make-sundae ‘my-ice :size ‘large :nuts ‘pecan) 
	= (my-ice large vanilla pecan) ;;모든 변수에 값을 넣었을 때
```
3. **&rest** - 임의개의 변수에 대한 것을 하나의 리스트로 받아주는 형태
4. **&aux** – 한 번에 하나씩 변수에 대한 초기값을 지정할 때 (LET*와 동일함.)

아래 예제를 통해 &rest와 &aux를 같이 살펴보자.

```lisp
(defun my-average (&rest Args ;;사용자로부터 Args에 값을 입력받는다. 그러나 몇 개의 값이 들어올 지 모른다. 임의개의 변수를 입력받을 때 사용하는 &rest를 사용한다.
		(&aux (Len (length Args))) ;;args 값을 받아 길이를 처리하고 이 것을 Len이라는 변수에 담아라. 
"usage of rest and aux"
(/ (reduce #’+Args) Len)) ;;reduce로 결과값을 합쳐주는 함수이다. 이 함수를 이용해 Args에 담긴 값을 전부 더하고, 더한 값을 len으로 나눠라. 
```

