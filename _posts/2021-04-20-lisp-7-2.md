---
title: "LISP 7주차 - LISP의 리스트 자료구조(2)"
excerpt: "LISP의 리스트 자료구조를 알아보자."
categories:
  - lectures
tags:
  - lisp
last_modified_at:
---

## Advanced List and Data Structures
집합을 리스트로 사용하는 때 사용하는 내장함수를 알아보자

## set-exclusive-or 내장함수
두 개의 집합에서 공통적인 원소를 ‘제외한’ 원소를 되돌려준다.

```lisp 
(set-exclusive-or '(0 1 2) '(1 0 2))
	= nil
(set-exclusiv-or '(0 1 2) '(0 1 3))
	= (3 2)
(set-exclusive-or '(0 0 0) '(1 1 1)
	= (1 1 1 0 0 0)
```

## Remove-duplicates 내장함수
집합이나 리스트에서 중복된 것을 제외하고 되돌려주는 함수

```lisp
(remove-duplicaes '(1 1 1 0 0 0))
	= (1 0)
```

## Member

집합의 원소인지 물어보는 함수이다. 주소를 가지고 동일성을 테스트하는 EQL을 사용한다.  
만약, member을 사용하면서 내용을 가지고 동일성을 테스트하고자 한다면 :test #'equal를 사용한다. (동등함을 비교하는 내장함수를 equal로 변경)  


```lisp
(setf cards '((3 clubs) (5 diamonds)))
(member '(5 diamonds) cards)
	= nil
(member '(5 diamonds) cards :test #' equalp)
	= ((5 diamonds))
(remove '(5 diamonds) cards :test #' equal)

(member 'a '(a b c)) ;;(a b c) 원소 중 a가 있는가?
	= (a b c) ;;찾고자 한 원소를 포함한 나머지 원소를 모두 출력함.
(member 'b '(a b c d)) ;;(a b c d) 원소 중 b가 있는가?
	= (b c d) ;;찾고자 한 원소를 포함한 나머지 원소를 모두 출력함. 

(defun before (x y l)
"returns true if x appears before y in"
(member y (member x l)))) ;;먼저 x가 l의 멤버인지 물어보고, 그 다음에 y가 멤버인지 물어본다. 그렇다면 l에서 x가 앞에 있는지 아닌지 알 수 있다. 

(beforep 'a 'b '(a b c d))
	= (b c d) ;;첫 번째로 a가 abcd의 멤버인 것을 확인했고, 그리고 b가 abcd의 멤버이므로 true값인 (b c d)를 출력한다.
(before 'b 'a '(a b c d)) 
	= nil ;;첫 번째로 b가 abcd의 멤버임을 확인했으나 bcd 뒤로는 a가 없으므로 b가 a 뒤에있는 것이 확인된다. 따라서 nil값이 리턴된다. 

(defun before (x y l)
"returns true if x appears before y in l"
(and (member y (member x l)) t))
```

Member처럼 :test를 통해 동등함을 비교하는 내장함수를 변경할 수 있는 함수로는 union, intersection, set-difference, assoc, rassoc, subst, sublis 가 있다.

## 집합을 알려주는 함수들

1. **Intersection** 교집합

```lisp
(intersection '(fred john mary) '(sue mary fred))
	= (fred mary)
```
2. **Union** 합집합

```lisp
(union '(a s d f g) '(v w s r a))
```
3. **Set-difference** 차집합

```lisp
(set-difference '(a s d f g) '(v w s r a))
```

4. **Subsetp** 부분집합이냐? 

```lisp
(subsetp '(a i) '(a e i o u))
```

## Programming with sets

```lisp
(defvar *male-names*
	'(john kim Richard fred george))
(defvar *female-names*
	'(jane mary wanda Barbara kim))
(defun gender-ambiguous-names ()
"both gender"
	(intersection *male-names* *female-names*))
(defun uniquely-male-names ()
"only for male"
	(set-difference *male-names* *female-names*))
(defun uniquely-female-names ()
"only for female"
	(set-difference *female-names* *male-names*))

(defun malep (names)
"checking whether the names are for male"
(and (member names *male-names*) ;;입력받은 이름이 male-names에 포함되거나
     (not (member names *female-names*)))) ;;입력받은 이름이 female-names에 포함되지 않으면 남자 이름이라고 (t) 출력한다.

(malep 'jane)
	= nil
(malep 'richard)
	= t

(defun femalep (names)
"checking whether the names are for female"
(and (member names *female-names*) ;;입력받은 이름이 female-names에 포함되거나
     (not (member names *male-names*)))) ;;입력받은 이름이 male-names에 포함되지 않으면 여성 이름이라고 (t) 출력한다.
```

## Subst (substituting)

Substituting one item for another everywhere it appears in a list. (substitute A for B, 두 번째 argument를 첫 번째 argument로 바꾼다.)  

```lisp
(subst 'on 'off '(keep off the grass)) ;;만약 입력값에 off가 발생하면 그것을 on으로 바꾼다. 
= (keep on the grass) 
(subst 'off 'on '(keep off the grass)) ;;만약 입력값에 on이 발생하면 그것을 off로 바꾼다.
	= (keep off the grass ;;하지만 입력값에 on이 발생하지 않았으므로 그대로 출력된다. 
```

## Sublis 
Making many substitutions simultaneously.

```lisp
(sublis '((roses . violets) (red. blue) ;;roses가 입력되면 violet으로, red가 입력되면 blue로 바꾼다. 가운데에 무조건 온점을 찍어줘야 한다. 
	= '(roses are red)) 
```

## Table
1. **Assoc**
2. **Rassoc** (reverse association)  
assoc은 키 값이 첫번째 열이지만, rassoc은 키값이 마지막 원소이다. 따라서 꼭 dotted notation으로 써야 한다. 

```lisp
(setf sounds '((cow. Moo) (pig . oink)))
(rassoc 'cow sounds)
	= nil ;;rassoc은 마지막 키값을 원소로 가지기 때문에 첫 번째 키값으로 원소를 찾으려 하면 error가 뜬다. 
(rassoc 'oink sounds)
	= (pig . oink) ;;이렇게 마지막 원소로 검색해주면 키값을 찾는다.
```

## Table 예제

```lisp
(defparameter *Things*
'((object1 large green shiny cube) ;;1행. object1에 large green shiny cube를 담는다.
 	(object2 large red dull pyramid) ;;2행. object2에 large red dull pyramid를 담는다. 
 	(object3 small green dull cube)))

(defvar *Quality-Table*
'((large . size) (small . size) ;;object 1, 2에 들어간 첫 번째 원소의 내용을 쓴다. 
 	(red . color) (green . color) ;;두 번째 원소의 내용을 쓴다. Red와 green은 색깔이다.
 	(shiny . luster) (dull . luster) ;;세 번째 원소의 내용을 쓴다. 둘은 luster이다.
 	(cube . shape) (pyramid . shape))) ;;네 번째 원소의 내용을 쓴다. Cube와 pyramid는 shape이다.

(defun description (x)
(cdr (assoc x *Things*))) ;;Things에 x가 포함되어있으면 이 값을 지운다. 즉, object1이 가지고 있는 원소 값만 출력한다. (ex – (large green shiny cube))

(defun differences (x y) 
(Set-exclusive-or (description x) (description y))) ;;y값에 x값이 있으면 object 값을 지우고, x와 y가 가지고 있는 공통분모를 제외한 것을 출력한다. (다른 값만 출력한다.)

(defun contrast (x y)
(remove-duplicates 
  (sublis *Quality-Table* (differences x y)))) ;;Quality-Table에 있는 첫 번째 원소의 값이 두 번째 원소의 값으로 바뀐다. (ex. green . color가 color로 바뀜.) 그리고 중복되는 값을 지워서 color가 하나만 나오게 한다. 즉, 각 요소의 설명 부분만 출력된다.

(description 'object1)
	= (large green shiny cube) ;;object1이 가지고 있는 원소들이 출력된다. 단, 이 때 object1이라는 값은 출력되지 않는다. 
(description 'object2)
	= (large red dull pyramid)
(description 'object3)
	= (small green dull cube)

(differences 'object1 'object2)
	= (pyramid dull red cube shiny green) ;;object1과 object2가 가지고 있는 원소들 중 중복되는 것을 제외한 나머지 원소를 출력한다. 이 때도 마찬가지로 object1,2 값은 출력되지 않는다. 
(contrast 'object1 'object2)
	= (shape lushter color) ;;각 원소가 다른 부분을 출력해준다. Object1과 object2는 shape, luster, color모든 항목이 다르므로 shape, luster, color가 출력된다.
(differences 'object1 'object3)
	= (dull small shiny large)
(contrast 'object1 'object3)
	= (luster size) ;;object1과 object3는 luster값과 size값만이 다르므로 luster, size값이 출력된다. 
```