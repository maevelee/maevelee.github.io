---
title: "LISP 7주차 - LISP의 리스트 자료구조(1)"
excerpt: "LISP의 리스트 자료구조를 알아보자."
categories:
  - lectures
tags:
  - lisp
last_modified_at:
---

## Advanced List and Data Structures

Cons cell 표기법에 대한 이해를 바탕으로 리스트가 어떻게 관리되어지는지 이해해보자.

## Table (ASSOC, association) 

```lisp
(defvar *Professions* ‘((lawyer mary)
						(dentist fred)
						(student lura)))

(defun find-someone (x)
"finding someone in a table"
(second (assoc x *Professions*))) ;;x로 입력받은 키 값과 *Professions*안에 있는 원소와 연관있는 것을 가져온다. 그리고, 그 행의 두 번째 원소를 되돌려준다. 

 (find-someone) 'dentist
	= fred
```

```lisp
Stack (Push, Pop)
(defvar *MyStack* nil) ;;빈 스택인 MyStack을 설정한다.
(push 'dish1 *MyStack*) ;;MyStack 스택에 dish1 값을 저장한다. 
	= (dish1)
```

```lisp
(push 'dish2 *MyStack*) ;;MyStack 스택에 dish2 값을 저장한다.
	= (dish2 dish1) ;;값이 저장되었음을 확인할 수 있다.

(pop *MyStack*) ;;스택에서 맨 위에 있는 값을 꺼낸다.
	= dish 2 ;;dish2가 꺼내졌다.

*MyStack* ;;스택 안의 값을 살펴보면
	= (dish1) ;;처음 저장되어있던 dish1값만 남아있음을 확인할 수 있다. 
```

## Reverse 함수
리스트에 있는 원소들의 순서를 역으로 바꿔 순서함

```lisp
(reverse '(a b c))
	= (c b a)
```

## NTH
nth번째 순서의 원소를 출력함

```lisp
(nth 0 '(a b c))
	= a

(nth 2 '(a b c))
	= c
```

## NTHCDR
nthcdr = 입력한 값 만큼 cdr을 실행함.

```lisp
(nthcdr 0 '(a b c))
	= (a b c)

(nthcdr 1 '(a b c))
	= (b c)
```

```lisp
(defun my-nth (n x)
"returns the Nth element of the list X, counting from 0."
(car (nthcdr n x))

(my-nth 0 ‘(a b c))
	= a

(my-nth 2 ‘(a b c))
	= c
```

## Last
List의 마지막 cons cell을 반환함. 

```lisp
(last '(ab c))
	= (c) 

(last '(a b (c)))
	= ((c))
```

## Remove
특정 원소를 리스트에서 지움

```lisp
(setf My-text '(b a n a n a – p a n d a))
(setf tpl:*print-length* nil) ;;출력 길이 제한 풀기 

(remove ‘a Mytext)
	= (b n n – p n d)

(setf MyResult (remove 'a MyText))
	= (b n n – p n d)
```

## :COUNT  

앞에 콜론이 붇는 count는 특정 내장함수 내에서 함수가 수행하는 행동을 지정할 수 있는 것을 keyword라고 한다. Count는 lisp의 keyword 중 하나이다.  
Remove 함수로 리스트 내에 있는 원소를 지울 때 횟수를 지정할 수 있음.

```lisp
(remove 'a MyText :count 2)
	= (b n n a – p a n d a)
```

```lisp
Keywordp = 특정 단어가 키워드에 해당하는지 확인하는 함수
Returning T if its input is a keyword 
(keywordp :count)
```

## Equality of object
Object의 동등함을 확인하는 내장함수는 크게 세 가지 종류가 있다. 

1. **EQ, EQL**  
주소를 비교하여 동등함을 확인한다.  
2. **Equal, Equalp**  
내용을 비교하여 동등함을 확인한다.  
3. **=**  
수를 서로 비교하여 동등함을 확인한다. 

```lisp
(= 7 7)
	= t

( = 7 8)
	= nil

(atom 'a)
	= t

(atom '(a))
	= nil

(atom 8)
	= t

(eq 'a 'a)
	 = t ;;심볼 a는 서로 나눌 수 없는 것으로 보기 때문에(atom 이다.) 따라서 동일하게 여겨진다. 

(eq '(a) '(a))
	= nil ;;a가 리스트 안의 원소가 된 이상, LISP은 cons cell을 통해 메모리를 잡아 리스트를 관리하므로 두 원소가 담긴 리스트의 메모리 주소는 같지 않게 된다. 따라서, 주소로 동일성을 판단하는 eq는 이 둘을 동일하지 않다고 본다. 

(eq "a" "a")
	= nil ;;string 역시 각기 다른 메모리 공간에서 저장하고 있다고 보기 때문에 nil값을 반환한다. 

(eql 'a 'a)
	= t

(eql '(a) '(a))
	 = nil ;;eql의 사용법은 eq와 완전히 동일하다. 

(equal '(a) '(a))
	= t ;;equal의 경우 내용으로 동일성을 판단하기 때문에 t 값을 반환한다.

(equal "a" "a")
	= t 

(equal "abc" "ABC")
	= nil ;;다만, 대소문자를 구별한다. 

(equalp "abc" "ABC")
	= t ;;equalp의 경우 equal과 동일하나 대소문자를 구별하지 않는다는 차이점이 있다. 

(setf x '(a b c)) ;;x에 a b c 값을 가지는 리스트를 넣었다.

(setf y '(a b c)) ;;y에 같은 값을 넣었다.

(eql x y) 
	= nil ;;내용은 같지만 x와 y는 각각 다른 메모리 주소를 갖기 때문에 주소로 동일성을 판단하는 eq에서는 같지 않다고 나온다.

(equal x y) 
	= t ;;하지만 내용으로 동일성을 판단하는 equal에서는 같다고 나온다.

(setf z x)

(eq x z)
	= t ;;하지만 z에 x값을 넣을 경우, z값이 x변수의 메모리 주소를 포인팅 하기 때문에 두 주소가 가지는 값은 같게 되고, eq는 t를 반환한다. 
```






