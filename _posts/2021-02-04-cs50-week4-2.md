---
title: "CS50 4주차 - 선형 검색, 이진 검색"
excerpt: "검색 알고리즘(선형 검색, 이진 검색)을 알아보자."

categories:
  - TIL
tags:
  - CS50
last_modified_at: 2021-02-04T22:38:00-12:00
---

## 검색 알고리즘인 선형검색, 이진검색을 알아보자.


이전 게시물에서 알고리즘 실행 시간 표기법을 다뤘다.

그렇다면 어떤 값이 배열 안에 속해 있는지 찾아볼 수 있는 검색 알고리즘에는 무엇이 있을까?
어떤 알고리즘이 어떠한 상황에 쓰이고, 가장 효율적인 알고리즘은 어떤 것일까?

어떤 값이 배열 안에 속해 있는지 찾아보기 위해서는 크게 두 가지 검색 알고리즘을 사용할 수 있다. 

첫 번째는 **선형 검색**이며, 두 번째는 **이진 검색**이다.


### 선형 검색


선형 검색은 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검색한다. 예를 들자면, 1부터 50까지의 숫자 나열에서 50이라는 값을 배열에서 찾기 위해 1부터 50까지 사물함을 하나하나 열어보는 검색 방법이다.

따라서, 배열이  정렬되지 않고 뒤죽박죽인 상황에서 유용한 검색 방법이다.

선형 검색은 아래 의사코드와 같이 나타낼 수 있다.


![](https://imageshack.com/i/pmpSm99pj){: .align-center} 


<span style='color:red'>__선형 검색 알고리즘__</span>은 **정확하지만 아주 효율적이지 못한 방법**이다.


리스트의 길이가 n이라고 했을 때, 최악의 경우 리스트의 모든 원소를 확인해야 하므로 n번만큼 실행된다. (O(50)이다.) 만약 100만개의 원소가 있는 리스트에서 50일 검색핸다고 가정해보자. 최악의 상황에서 컴퓨터는 100만개의 원소를 다 찾아봐야 한다.

따라서, 선형 검색 실행 시간의 상한은 **O(n)**이다. 하지만 실행 시간의 하한은**Ω(1**)이다. 운이 좋다면 한 번에 바로 값을 찾을 수도 있기 때문이다. 교실 뒤 사물함에서 내 사물함을 찾고 싶어서 첫번째 사물함을 열었는데, 그게 내 사물함일 수도 있는 것이다. 

때문에 선형 검색은 **자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 무조건 하나씩 찾아야 하는 경우에 유용**하다. 이러한 경우 무작위로 탐색하는 것보다 순서대로 탐색하는 것이 더 효율적이기 때문이다. 


+ **O(n^2**)
+ **O(n log n)**
+ **O(n)** **-선형 검색**
+ **O(log n)**
+ **O(1)**

+ **Ω(n^2)**
+ **Ω(n log n)**
+ **Ω(n)**
+ **Ω(log n)**
+ **Ω(1)** **- 선형 검색**



주어진 배열에서 특정 값을 찾기 위해 선형 검색을 사용한다면, 아래와 같은 코드를 작성할 수 있다.


![](https://imageshack.com/i/pnqfDBAAj){: .align-center}


배열의 크기만큼 for루프를 돌면서 배열의 인덱스를 차례대로 방문하며 찾는 값이 있는지 검사하면 된다.

문자열로 이루어진 배열도 비슷한 방식으로 검색할 수 있다.

만약 전화번호부에서 특정 이름을 찾아 해당하는 전화번호를 출력하는 프로그램을 작성한다면 아래와 같이 나타낼 수 있다. 


![](https://imageshack.com/i/pmyNCDZVj){: .align-center}


위와 같이 names 배열과 numbers 배열을 따로 정의하고 names 배열에서 검색을 해서 해당하는 인덱스의 numbers 배열 값을 출력하는 형태이다.

그러나, 이 코드는 names 배열과 numbers 배열이 서로 같은 인덱스를 가져야 한다는 한계가 있다. 전화번호가 더 많이 입력된다면 names[100] 의 이름과 numbers[100] 의 번호가 다른 사람의 번호일 수 있다. 

따라서, 더 좋은 방법은 아래 코드와 같이 새로운 자료형으로 **구조체**를 정의하여 이름과 번호를 묶어주는 것이다.


![](https://imageshack.com/i/poBsJt8Vj){: .align-center}
![](https://imageshack.com/i/pmUSvpVdj){: .align-center}


위와 같이 person 이라는 이름의 구조체를 자료형으로 정의하고 person 자료형의 배열을 선언하면 그 안에 포함된 속성값은 '.'으로 연결해서 접근할 수 있다.

person a;라는 변수가 있다면, a.name 또는 a.number 이 각각 이름과 전화번호를 저장하는 변수가 된다.



### 이진 검색


이진 검색은 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복하는 검색 방법이다.

예를 들자면, 1부터 50까지의 숫자 중에서 30을 찾고자 한다면 인덱스의 중간인 25부터 시작하여 큰 값이 저장되어 있는 인덱스를 타고 26, 27, 28, 29, 30 순으로 올라가 30을 찾아내는 식이다. 단, 이 때 배열은 정렬되어 있어야 한다.

이진 검색 실행 시간의 상한선은 **O(log n)**이다. 리스트를 절반으로 나누어 검색하기 때문이다. 실행 시간의 하한선은 **Ω(1)**이다. 선형 검색과 마찬가지로, 운이 좋다면 찾고자 하는 수가 리스트의 절반 자리에 위치해있을 수도 있기 때문이다.


+ **O(n^2**)
+ **O(n log n)**
+ **O(n)** **- 선형 검색**
+ **O(log n)** **- 이진 검색**
+ **O(1)**

+ **Ω(n^2)**
+ **Ω(n log n)**
+ **Ω(n)**
+ **Ω(log n)**
+ **Ω(1)** **- 선형 검색, 이진 검색**


이진 검색은 아래 의사코드와 같이 나타낼 수 있다.


![](https://imageshack.com/i/pozX9Lvmj){: .align-center}


이진 검색은 선형 검색보다 훨씬 빨리 값을 찾아낼 수 있으나, 배열이 정렬되어 있지 않은 상태라면 선형 검색이 이진 검색보다 빠르다. 그렇기 때문에 이진검색은 정렬된 배열에서 사용해야 하는 검색 알고리즘이다.

하지만 위에서 설명했듯이 선형 검색은 정확하지만 아주 효율적이지 못한 방법이다. 따라서, 정렬되지 않은 리스트를 탐색하는 것 보다는 정렬한 리스트를 탐색하는 것이 더 효율적이다.




