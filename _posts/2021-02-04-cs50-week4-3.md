---
title: "CS50 4주차 - 버블 정렬, 선택 정렬"
excerpt: "정렬 알고리즘(버블 정렬, 선택 정렬)을 알아보자."

categories:
  - TIL
tags:
  - CS50
last_modified_at: 2021-02-05T01:07:00-13:00
---

## 정렬 알고리즘(버블 정렬, 선택 정렬)을 알아보자. 

이전 게시글에서 정렬한 배열을 탐색하는 것이 정렬되지 않은 배열을 탐색하는 것보다 효율적이라고 설명했다. 

배열을 정렬하기 위한 방법은 여러가지가 있고, 각각 실행 시간도 다르다. 이번 게시글에서는 정렬 알고리즘인 버블 정렬, 선택 정렬을 알아보자. 



### 버블 정렬
- - -
버블 정렬은 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말한다. 

버블 정렬은 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다. 이 알고리즘은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다. 


아래와 같은 8개의 숫자가 임의의 순서로 나열되어 있다.

6 3 8 5 2 7 4 1 


버블 정렬 알고리즘을 사용하여 이 숫자들을 오름차순으로 정렬하면 아래와 같은 과정을 거친다. 
- - -


먼저 가장 앞의 6과 3을 비교한다. 6은 3보다 크므로 둘의 순서를 바꾼다.
교환 전: **6 3** 8 5 2 7 4 1
교환 후: **3 6** 8 5 2 7 4 1


다음 쌍인 6과 8을 비교한다. 앞 숫자인 6이 8보다 작으므로 교환하지 않는다.
교환 전: 3 **6 8** 5 2 7 4 1
교환 후: 3 **6 8** 5 2 7 4 1


이런 식으로 숫자 끝까지 진행하면 아래와 같이 정렬이 된다. 
3 6 5 2 7 4 1 8


위와 같은 방법을 다시 한 번 반복하면 아래와 같은 과정을 거친다.

**3 6** 5 2 7 4 1 8
3 **6 5** 2 7 4 1 8 (교환)
3 5 **6 2** 7 4 1 8 (교환)
3 5 2 **6 7** 4 1 8 
3 5 2 6 **7 4** 1 8 (교환)
3 5 2 6 4 **7 1** 8 (교환)
3 5 2 6 4 1 **7 8**


이 과정을 정렬이 올바르게 될 때까지 반복하면 최종적으로 아래와 같이 오름차순 정렬이 된다.
1 2 3 4 5 6 7 8
- - -

버블 정렬을 의사 코드로 나타내면 아래와 같다.


![](https://imageshack.com/i/pn2ruSK5j){: .align-center}


그렇다면 위 숫자들을 제대로 정렬하기 위해서 총 몇 번의 과정이 필요했을까? 시간은 얼마나 걸린걸까?

버블 정렬 실행 시간의 Big-O표기로 버블 정렬 알고리즘의 효율성을 체크해보자.


n개의 숫자 중 두 숫자의 위치를 비교하면 최대 n-1번 비교하게 된다. 또한, 각 인덱스 번호의 숫자와 인덱스 번호+1에 해당하는 숫자(뒤에 위치한 숫자)의 순서가 잘못됐다면 두 숫자의 위치를 교환해야 한다. 이를 식으로 나타내면 0 to n-2, 즉, n-1이다. 

따라서, 버블 정렬은 숫자를 비교하는 루프와 숫자를 교환하는 두 루프를 같이 돌아야 하므로 (n – 1) x (n – 1)로 표기할 수 있다. (n-1) x (n-1)은 n^2 – n – n + 1이며, 이를 동류항 처리하면 n^2 -2n +1이다. 


중요한 점은 지수가 가장 큰 n^2의 영향력이 가장 크다는 점이다. n이 커질수록 n^2가 미치는 영향은 더 커지기 때문에 컴퓨터과학에서는 이 수식을 간단히 하여 버블 정렬이 **O(n^2)**라고 말한다. 

버블 정렬은 정렬이 되어 있는지 여부에 관계없이 루프를 돌며 비교를 해야 하므로 버블 정렬의 실행 시간 하한인 Big Ω는 **Ω(n^2)**이 된다. 

- - -

**O(n^2) - 버블 정렬
O(n log n)
O(n) - 선형 검색
O(log n) - 이진 검색
O(1)

Ω(n^2) - 버블 정렬
Ω(n log n)
Ω(n) 
Ω(log n)
Ω(1) - 선형 검색, 이진 검색**

- - -


위에서 Big O를 알아보며 선형 검색은 O(n)이고 이진 검색은 O(log n)임을 설명했다. 이렇게만 보면 이진 검색이 선형 검색보다 효율적인 알고리즘이다. 

하지만, 이진 검색은 값이 이미 정렬되어 있는 상태에서 사용해야 하는 검색 알고리즘이다. 만약 버블 정렬 알고리즘을 이용하여 값을 정렬하고, 그 후 이진 검색 알고리즘을 사용한다면 버블 정렬은 O(n^2), 이진 검색은 O(n)이므로 오히려 선형 검색이 버블 정렬+이진 검색보다 훨씬 효율적이다. 

과연 이 방법이 최선일까? 
우리에게는 다른 정렬 알고리즘인 선택 정렬 역시 있다. 선택 정렬을 알아보자. 

- - -
### 선택 정렬
- - -


선택 정렬은 배열 안의 자료 중 가장 작은, 혹은 큰 수를 찾아 첫 번째 위치 혹은 마지막 위치의 수와 교환해주는 방식의 정렬이다.

선택 정렬은 교환 횟수를 최소화할 수 있다. 하지만, 각 자료를 비교하는 횟수는 증가한다. 


- - -
아래와 같은 정렬되지 않은 숫자들을 선택 정렬을 이용해 오름차순으로 정리해보자.
6 3 8 5 2 7 4 1


먼저 아래 숫자들 중에서 가장 작은 값을 찾는다.
6 3 8 5 2 7 4 **1**


가장 작은 값인 1은 가장 앞에 있어야 하므로 현재 리스트의 첫 번째 값인 6과 1자리를 교환한다.
**1** 3 8 5 2 7 4 **6**


그리고 정렬되어 있는 1은 제외하고, 두 번째 숫자부터 시작해서 또 가장 작은 값을 찾는다.
1 3 8 5 **2** 7 4 6


가장 작은 값인 2는 정렬되지 않은 숫자들 중에서 가장 앞에 있어야 하므로 3과 교환한다.
1 **2** 8 5 **3** 7 4 6


이 과정을 더 이상 교환이 일어나지 않을 때까지 반복하면 아래와 같이 오름차순 정렬이 완료된다.
1 2 3 4 5 6 7 8


- - -

이와 같은 선택 정렬을 의사 코드로 나타내면 아래와 같다. 

![](https://imageshack.com/i/pmRAxs3Lj){: .align-center}


선택 정렬 역시 두 번의 루프를 돌아야 한다. 바깥 루프에서는 숫자들을 처음부터 순서대로 방문하고, 안쪽 루프에서는 가장 작은 값을 찾아야 하기 때문이다.

따라서 소요 시간의 상한은 O(n^2)가 되며, 하한 역시 Ω(n^2)이다.

- - -

**O(n^2) - 버블 정렬, 선택 정렬
O(n log n)
O(n) - 선형 검색
O(log n) - 이진 검색
O(1)

Ω(n^2) - 버블 정렬, 선택 정렬
Ω(n log n)
Ω(n) 
Ω(log n)
Ω(1) - 선형 검색, 이진 검색**

- - -


